/****************************************************************
filename: mainflow.cpp
module:
created by: ouyh
create date: 
version: 3.0.0
description:
    插件运行平台
*****************************************************************/
#include "MainFlow.h"

using namespace filterchain;

CDatabase DBConn;
CLog theLog;

bool bGetExitSig;

int main(int argc, char **argv)
{
	C_MainFlow process;
	process.printVersion();

	if(!process.checkArg(argc, argv))
	{
		return -1;
	}

	try
	{
		signal(SIGTERM, dealSignal);
		
		if(!process.init())
		{
			goto Exit;
		}

		while(!bGetExitSig)
		{
			//process.Update();
			process.run();
		}
Exit:
		theLog<<"安全退出程序"<<endi;
		/* 断开数据库连接 */ 
		process.exit();
		if (DBConn.IsConnected() == 1)
			DBConn.Disconnect();
		return 0;
	}
	catch(jsexcp::CException &e) 
	{
		errLog(4, " ", e.GetAppError(), (std::string("运行平台层出错: ") + e.GetOrgErrMessage()).c_str(), __FILE__, __LINE__, e);
	}
	catch(...)
	{
		//cout<<"收到系统发出的异常信息："<<errno<<endl;
		errLog(4, " ", errno, "运行平台层出错", __FILE__, __LINE__);
	}
};

C_MainFlow::C_MainFlow()
{
	vecFile.clear();
	memManager = NULL;
	chain = NULL;
	pps = NULL;
	res = NULL;
	pListSql = NULL;
	iRunTime = -1;
	m_bDBLinkError = FALSE;
}

C_MainFlow::~C_MainFlow()
{
	vecFile.clear();
	releasePoint();
}

void C_MainFlow::releasePoint()
{
	if(memManager != NULL)
	{
		delete memManager;
		memManager = NULL;
	}
	if(pps != NULL)
	{
		delete pps;
		pps = NULL;
	}
	if(res != NULL)
	{
		delete res;
		res = NULL;
	}
	if(pListSql != NULL)
	{
		delete pListSql;
		pListSql = NULL;
	}
}

void C_MainFlow::printVersion()
{
	/* 输出模块的主流程名称、版本等信息 */
	printf("*************************************************** \n");
	printf("*   	GuangDong Telecom. %s System	\n" , SYSTEM_NAME );
	printf("*                                                   \n");
	printf("*		%s \n", MODULE_NAME);
	printf("*		  Version %s	\n", VERSION_NO);
	printf("*      last updated: %s by %s	\n", UPDATE_TIME, WHO_UPDATE );
	printf("*************************************************** \n");
};

bool C_MainFlow::checkArg(int argc, char** argv)
{	
	/* 检查输入参数是否正确 */
	if (!(argc == 4 || argc == 5))
	{
		/* 输入参数：平台编号 数据源组编号 进程index 环境变量文件 */
		printf("Usage : %s <service_id> <source_group> <process_index> [<env_path>]\n",argv[0]);
		return false;
	}

	/* 从输入参数中读取变量 */
	/*
	int iRet = dispartFullName(argv[0], m_szExePath, m_szExeName);
	if(iRet != 0 && iRet != 2)
	{
		cout << "分解执行文件名出错！" << endl;
		return false;
	}
	*/
	char szPathTmp[FILE_NAME_LEN+1];
	strcpy(szPathTmp, argv[0]);
	if(!strncmp(szPathTmp,"../",3))
	{
		getcwd(m_szExePath, PATH_NAME_LEN+1);
		sprintf(m_szExePath, "%s/%s", m_szExePath, szPathTmp);
		strncpy(m_szExeName, strrchr(szPathTmp,'/')+1, strlen(szPathTmp)-(strrchr(szPathTmp,'/')-szPathTmp)+1);
	}
	else if(!strncmp(szPathTmp,"./",2))
	{
		getcwd(m_szExePath, PATH_NAME_LEN+1);
		strncpy(m_szExeName, strrchr(szPathTmp,'/')+1, strlen(szPathTmp)-(strrchr(szPathTmp,'/')-szPathTmp)+1);
	}
	else if(!strncmp(szPathTmp,"/",1))
	{
		strncpy(m_szExeName, strrchr(szPathTmp,'/')+1, strlen(szPathTmp)-(strrchr(szPathTmp,'/')-szPathTmp)+1);
		strncpy(m_szExePath, szPathTmp, strlen(szPathTmp)-strlen(m_szExeName));
	}
	else
	{
		getcwd(m_szExePath, PATH_NAME_LEN+1);
		strcpy(m_szExeName, szPathTmp);
	}
	cout<<"szProgramPath="<<m_szExePath<<endl;
	cout<<"szProgramName="<<m_szExeName<<endl;
	strcpy(Param.szServiceId, argv[1]);
	strcpy(Param.szSourceGroupId, argv[2]);
	Param.iProcessId = atoi(argv[3]);
	if(argc == 4)
	{
		strcpy(m_szEnvFile,getenv("ZHJS_INI"));
		strncpy(m_szEnvPath, m_szEnvFile, strlen(m_szEnvFile)-8);
	}
	else
	{
		strcpy(m_szEnvPath, argv[4]);
		if(m_szEnvPath[strlen(m_szEnvPath)-1] != '/')
			strcat(m_szEnvPath, "/");
		sprintf(m_szEnvFile, "%szhjs.ini", m_szEnvPath);
	}

	return true;
};

bool C_MainFlow::init()
{
	iUndoFlag = 0;
	iRad = 1;
	iRunTime = 0;

	char szCurrentTime[DATETIME_LEN+1];
	char szLogStr[LOG_MSG_LEN+1];             //日志信息
	char szSqlStr[SQL_LEN+1];					//存储临时sql语句的变量
	char szTemp[FIELD_LEN+1];
	bGetExitSig = false;
	CReadIni IniFile;
	
	/* 从环境变量文件中读取参数 */
	if(!IniFile.init(m_szEnvFile))
	{
		cout<<"打开INI文件出错： "<<m_szEnvFile<<endl;
		return false;
	}
  
	/* 声明进程的共享内存管理类对象 */
	char szIPCKeyPath[PATH_NAME_LEN+1];
	/*
	if( !IniFile.GetValue("PROCINFO_SHM", "ipckey_path", szIPCKeyPath) )
	{
		sprintf(szLogStr, "配置文件中的服务信息共享内存IPCKEY目录[PROCINFO_SHM-ipckey_path]未设置!");
		cout<<szLogStr<<endl;
		return false;
	}
	*/
	
	/* 初始化日志 */
	char szLogPath[PATH_NAME_LEN+1];
	char szLogLevel[10];
	IniFile.GetValue("COMMON", "LOG_PATH", szLogPath, 'N');
	IniFile.GetValue("COMMON", "LOG_LEVEL", szLogLevel, 'N');
	theLog.setLog(szLogPath, atoi(szLogLevel), Param.szServiceId, Param.szSourceGroupId, Param.iProcessId);
	
	//设置为后台常驻进程
	memset(szTemp, 0, sizeof(szTemp));
	IniFile.GetValue("COMMON", "DAEMON_MODE", szTemp, 'N');
	if(!strcmp(szTemp, "Y"))
		initDaemon(true);
	theLog.reSetLog();

	// 信息点日志
	Param.info.SetEnvPath(m_szEnvPath);
	Param.info.configInfoLog(Param.szServiceId, Param.szSourceGroupId, Param.iProcessId, m_szExeName, m_szExePath);
	Param.info.msgInfoLog(INFO_START);

	//打印启动命令
	theLog<<"启动命令："<<m_szExeName<<"  "<<Param.szServiceId<<"  "<<Param.szSourceGroupId<<"  "<<Param.iProcessId<<endi;
	theLog<<"ENV_FILE = "<<m_szEnvFile<<endi;

	try
	{
		
		/* 连接数据库 */
		theLog<<"开始连接数据库……"<<endd;
		try
		{
			connectDB(m_szEnvFile, DBConn);
			theLog<<"连接数据库成功。"<<endi;
		}
		catch(jsexcp::CException &e)
		{
			Param.info.msgInfoLog(INFO_INITFAIL);
			e.PushStack(PREDEAL_ERR_IN_CONNECT_DB, "连接数据库失败", __FILE__, __LINE__);
			throw e;
		}
		catch(...)
		{
			Param.info.msgInfoLog(INFO_INITFAIL);
			theLog<<"errno "<<errno<<ende;
			throw jsexcp::CException(PREDEAL_ERR_IN_CONNECT_DB, "连接数据库失败", __FILE__, __LINE__);
			//errLog(4, "无文件", errno, "连接数据库失败", __FILE__, __LINE__);
			//exit(1);
		}
	{
		CBindSQL ds(DBConn);
		
		/* 取队列关键字 */
		//strcpy( Param.szMsgKey, getMsgKey(IniFile, Param.szServiceId, Param.szSourceGroupId) );
		sprintf(szSqlStr, "select msgqueue from c_service_group_config where service_type = 'S' and service = '%s' \
			and source_group = '%s' and prog_name = 'service'", Param.szServiceId, Param.szSourceGroupId);
		ds.Open(szSqlStr, SELECT_QUERY );
		if (!(ds>>Param.szMsgKey))
		{
			ds.Close();
			Param.info.msgInfoLog(INFO_INITFAIL);
			sprintf(szLogStr, "执行 %s 出错！", szSqlStr);
			errLog(4, "初始化失败", errno, szLogStr, __FILE__, __LINE__);
			return false;
		}
		theLog<<"Message Key="<<Param.szMsgKey<<endi;	
		respMsgHandle.Init(Param.szMsgKey);
		/* 声明进程的共享内存管理类对象 */	
		memset(szIPCKeyPath, 0, sizeof(szIPCKeyPath));
		if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "IPCKEY_PATH", szIPCKeyPath ) == -1 )
		{
			sprintf(szLogStr, "服务信息共享内存IPCKEY目录[IPCKEY_PATH]未设置!");
			theLog<<szLogStr<<endi;
			return false;
		}
		Param.ProcMonitor.SetIPCKeyPath(szIPCKeyPath);
		Param.ProcMonitor.Attach();
		Param.ProcMonitor.Init(m_szExeName, Param.szServiceId, Param.szSourceGroupId, Param.iProcessId);
		Param.ProcMonitor.UpdateMonitor(CProcInfo::SERV_IDLE);

		getSourceInfo();
		/* 初始化中间变量 *
		memset(m_szSourceId,0,sizeof(m_szSourceId));
		memset(m_szLocalTollcode,0,sizeof(m_szLocalTollcode));
		memset(m_szSysTime, 0, sizeof(m_szSysTime));
		memset(m_szFileName, 0, sizeof(m_szFileName));
		memset(m_szNewName, 0, sizeof(m_szNewName));
		/* 绑定到语法树上去 *
		Compile.DefineVariable("SOURCE_ID",m_szSourceId);
		Compile.DefineVariable("LOCALTOLL",m_szLocalTollcode);
		Compile.DefineVariable("SYS_TIME",m_szSysTime);
		Compile.DefineVariable("FILE_NAME",m_szFileName);
		Compile.DefineVariable("NEW_NAME",m_szNewName);
		*/

		if(pListSql != NULL)
		{
			delete pListSql;
			pListSql = NULL;
		}
		iListCount = 0;
		// 查询是否有使用条件表达式list，如果有需要根据list_sql来判断表记录是否被更新了
		ds.Open("select count(*) from i_list_sql", SELECT_QUERY );
		if (!(ds>>iListCount))
		{
			ds.Close();
			Param.info.msgInfoLog(INFO_INITFAIL);
			strcpy(szLogStr, "执行 select count(*) from i_list_sql 出错！");
			errLog(4, "初始化失败", errno, szLogStr, __FILE__, __LINE__);
			return false;
		}
		ds.Close();
		if( iListCount > 0 ) 
		{
			STmpVariable sVar;
			pListSql = new SListSql[iListCount];
			if( pListSql == NULL )
			{
				Param.info.msgInfoLog(INFO_INITFAIL);
				strcpy(szLogStr, "创建 SListSql 失败！");
				errLog(4, "初始化失败", errno, szLogStr, __FILE__, __LINE__);
				return false;
			}
//			ds.Close();
			ds.Open("select SQL_ID,UPDATE_FLAG from i_list_sql order by SQL_ID", SELECT_QUERY );
			for( int i=0; i < iListCount; i++ )
			{
				if( ds>>pListSql[i].m_szSqlId>>pListSql[i].m_szUpdateFlag )
				{
					sprintf( pListSql[i].m_szUpdateSqlName, "UPDATE_%s", pListSql[i].m_szSqlId);
					// 添加到中间变量 
					strcpy(sVar.szVarName, pListSql[i].m_szUpdateSqlName);
					strcpy(sVar.szVarValue, pListSql[i].m_szUpdateFlag);
					Param.map_DefVar.push_back(sVar);
					//Param.defaultVar.setDefVar(pListSql[i].m_szUpdateSqlName, pListSql[i].m_szUpdateFlag);
				}
				else
				{
					Param.info.msgInfoLog(INFO_INITFAIL);
					strcpy(szLogStr, "执行 select SQL_ID,UPDATE_FLAG from i_list_sql order by SQL_ID 出错！");
					errLog(4, "初始化失败", errno, szLogStr, __FILE__, __LINE__);
					ds.Close();
					return false;	
				}
			}//end of for( int i=0; i < iListCount; i++ )
			ds.Close();
			pListSql = &pListSql[0];
		}
	}
		/***********************************************************************************
		*从数据库中获取变量名对应的值
		***********************************************************************************/
		if( getScheme(Param) != 0 )
		{
			Param.info.msgInfoLog(INFO_INITFAIL);
			return false;
		}
		
		/***********************************************************************************
		*检查出口目录
		***********************************************************************************/
		CheckWorkpath();
			
		/***********************************************************************************
		*读取环境变量中的申请共享内存的地址
		***********************************************************************************/
		if(Param.bCommemFlag)
		{
			memManager = new C_AccessMem();
			memManager->init(Param.szServerId, m_szEnvPath);
		}

		pps = new PacketParser();
		res = new ResParser();

		/***********************************************************************************
		*初始化输出话单类、分拣类、无资料类、处理日志类、插件类和号码转换类
		***********************************************************************************/
		abnormity_type lack = abenum_lackinfo;		//无资料类型
		if(strlen(Param.szLackStatTableId)==0)
			Param.lack_info.Init( &DBConn, lack, atoi(Param.szLackSaveTableId) , NULL, Param.szServiceId );
		else
			Param.lack_info.Init( &DBConn, lack, atoi(Param.szLackSaveTableId) , Param.szLackStatTableId, Param.szServiceId );
		if(strlen(Param.szAbnStatTableId)==0)
			Param.abnormal.Init( &DBConn, lack, atoi(Param.szAbnSaveTableId) , NULL, Param.szServiceId );
		else
			Param.abnormal.Init( &DBConn, lack, atoi(Param.szAbnSaveTableId) , Param.szAbnStatTableId, Param.szServiceId );
		if( !strcmp(Param.szIsFmtFirst, "Y") )
		{
			if( !strcmp(Param.szFmtErr2Table, "Y") )
			{
				if(strlen(Param.szFmtErrStatTableId)==0)
					Param.fmt_err2table.Init( &DBConn, lack, atoi(Param.szFmtErrSaveTableId) , NULL, Param.szServiceId );
				else
					Param.fmt_err2table.Init( &DBConn, lack, atoi(Param.szFmtErrSaveTableId) , Param.szFmtErrStatTableId, Param.szServiceId );
			}
		}
		Param.pluginInitializer.initialize(Param.szServiceId, Param.szSourceGroupId, Param.szSlPath, Param.szSlName);
		cout<<"初始化插件树成功！"<<endl;
		if(chain != NULL)
		{
			//delete chain;
			chain = NULL;
		}
		chain = Param.pluginInitializer.getFilterChain();
		if(chain == NULL)
		{
			Param.info.msgInfoLog(INFO_INITFAIL);
			sprintf(szLogStr, "empty plugin ");
			errLog(4, "初始化失败", errno, szLogStr, __FILE__, __LINE__);
			return false;
		}
		ArgInit initPlugin;
		initPlugin.set(Param.szSourceGroupId, Param.szServiceId, Param.iProcessId, memManager);
		getCurTime(szCurrentTime);
		initPlugin.setTime(szCurrentTime, 0);
		//Argument *pInit = &initPlugin;
		chain->signal(&initPlugin);
		theLog<<"初始化成功！"<<endi;

	}//end of try
	catch (jsexcp::CException &e) 
	{
		Param.info.msgInfoLog(INFO_INITFAIL);
		e.PushStack(PREDEAL_ERR_IN_SELECT_DB, "初始化失败",  __FILE__, __LINE__);
		throw e;
	}
	catch(...)
	{
		Param.info.msgInfoLog(INFO_INITFAIL);
		//errLog(0, "初始化失败", errno, "遇到系统错误", __FILE__, __LINE__);
		throw jsexcp::CException(errno, "初始化失败", __FILE__, __LINE__);
	}

	// 信息点日志
	Param.info.msgInfoLog(INFO_INITSUC);
	return true;
}

void C_MainFlow::CheckWorkpath()
{
	theLog<<"检查临时出口目录是否有异常状态的文件......"<<endi;

	vector<string> vFileName;
	char szTemp[PATH_NAME_LEN+1];
	char szCheckedPath[PATH_NAME_LEN+1];
	char szFileName[PATH_NAME_LEN+1];
	char szRealName[PATH_NAME_LEN+1];
	char szPathName1[FILE_NAME_LEN+PATH_NAME_LEN+1];
	char szPathName2[FILE_NAME_LEN+PATH_NAME_LEN+1];
	char szLogStr[LOG_MSG_LEN+1];
	char szSqlStr[SQL_LEN+1];
	char cFlag;
	memset(szTemp, 0, sizeof(szTemp));
	memset(szCheckedPath, 0, sizeof(szCheckedPath));
	sprintf(szTemp, "~*.%d", Param.iProcessId);
	//sprintf(szTemp, "~*");

	char szCurrentTime[14+1];
	memset(szCurrentTime, 0, sizeof(szCurrentTime));
	getCurTime(szCurrentTime);
	char szTmpPart[2+1];
	memset(szTmpPart, 0, sizeof(szTmpPart));
	strncpy(szTmpPart, szCurrentTime+4, 2);
	char szPID[4];
	memset(szPID, 0, sizeof(szPID));
	sprintf(szPID, "%d", Param.iProcessId);
	
	CBindSQL ds(DBConn);
	for( map<string, SSourceStruct>::iterator iter=mapSource.begin(); iter!=mapSource.end(); iter++ )
	{
		vFileName.clear();
		memset(szCheckedPath, 0, sizeof(szCheckedPath));
		sprintf(szCheckedPath, "%s%stmp_out/", (iter->second).szSourcePath, Param.szInPath);
		cout<<"Search:"<<szCheckedPath<<endl;
		bool doneFlag = SearchAllFiles(szCheckedPath, szTemp, vFileName);
		//遍历符合条件的文件
		for(int k=0; k<vFileName.size(); k++)
		{
			memset(szFileName, 0, sizeof(szFileName));
			strcpy(szFileName, vFileName[k].c_str());
			strncpy(szRealName, szFileName+1, strlen(szFileName)-3);
			szRealName[strlen(szFileName)-3] = '\0';
			cout<<"Find File:"<<szFileName<<endl;
			sprintf(szSqlStr, "select deal_flag from %s where source_id='%s' and filename='%s' and partid in(%d,%d,%d)",
				Param.szLogTabname, (iter->second).szSourceId, szRealName, getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
			ds.Open(szSqlStr, SELECT_QUERY);
			if( !(ds>>cFlag) )
			{
				ds.Close();
				sprintf(szLogStr, "在表%s中找不到(数据源%s,文件%s)的记录", Param.szLogTabname, (iter->second).szSourceId,
					szRealName);
				//theLog<<szLogStr<<endw;
				//throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
			}
			if(cFlag == 'Y')
			{
				//上次异常未改名的文件，改名
				sprintf(szPathName1, "%s/%s", szCheckedPath, szFileName);
				strncpy(szPathName2, szPathName1, strlen(szPathName1)-strlen(szPID));
				szPathName2[strlen(szPathName1)-strlen(szPID)+1]='\0';
				if(rename(szPathName1, szPathName2) != 0 )
				{
					sprintf(szLogStr, "将文件 %s 改成 %s 失败！", szPathName1, szPathName2);
					throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
				}
				theLog<<"将文件 "<<szPathName1<<" 改成 "<<szPathName2<<endi;
			}
			else
			{
				//sprintf(szLogStr, "表%s中(数据源%s,文件%s)的记录异常", Param.szLogTabname, (iter->second).szSourceId,
				//	szRealName);
				//throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
			}
		}
	}
}

void C_MainFlow::Update()
{
	try
	{
		//theLog<<"更新共享内存……"<<endd;
		/* 更新共享内存 */
		if(Param.bCommemFlag)
			memManager->LoadOrUpdate();

		CBindSQL ds(DBConn);
		//如果有条件表达式list，则设置update_flag的值，用于判断是否更新了表记录
		ds.Open("select UPDATE_FLAG from i_list_sql order by SQL_ID", SELECT_QUERY );
		for( int i=0; i < iListCount; i++ )
		{
			if( !(ds>>pListSql[i].m_szUpdateFlag) )
			{
				ds.Close();
				//theLog<<"select UPDATE_FLAG from i_list_sql order by SQL_ID Error!"<<ende;
				throw jsexcp::CException(0, "执行 select UPDATE_FLAG from i_list_sql order by SQL_ID 失败！", __FILE__, __LINE__);
			}
			//pListSql++;
		}
		ds.Close();
		theLog<<"更新资料成功！"<<endd;
	}
	catch(jsexcp::CException &e)
	{
		Param.info.msgInfoLog(INFO_BREAK);
		throw;
	}
	catch(...)
	{
		Param.info.msgInfoLog(INFO_BREAK);
		throw jsexcp::CException(errno, "资料更新时遇到未知系统错误", __FILE__, __LINE__);
	}
}

void C_MainFlow::run()
{
MAINFLOW_REDO:
	try
	{
		Update();
		theLog.reSetLog();
		//cout<<"重设日志"<<endl;
		checkTime();
		//cout<<"检查是否跨日"<<endl;
		if(m_bDBLinkError)
		{
			//数据库重连
			vecFile.clear();
			iRunTime--;
		}
		iRunTime++;
		int iFileNum = 0;
		if(iRunTime == 1)
		{
			//resetHFiles();
			iFileNum = getFilesFromDB();
			if( iFileNum>0 )
			{
				iUndoFlag++;
				process();
			}
		}
		else
		{
			iFileNum = getFilesFromPPQ();
			if( iFileNum>0 )
			{
				process();
			}
			else
			{
				Param.ProcMonitor.UpdateMonitor(CProcInfo::SERV_IDLE);
				theLog<<"无文件，进程休眠……"<<endi;
				sleep(Param.iSleepTime);
			}
		}
	}
	catch(jsexcp::CException &e)
	{
		Param.info.msgInfoLog(INFO_BREAK);
		e.PushStack(e.GetAppError(), "处理批次文件出错", __FILE__, __LINE__);
		//是否是数据库链接失败
		char szTemp1[PATH_NAME_LEN+1];
		char szTemp2[PATH_NAME_LEN+1];
		memset(szTemp1, 0, sizeof(szTemp1));
		memset(szTemp2, 0, sizeof(szTemp2));
		char *ptr;
		strncpy(szTemp1, e.GetOrgErrMessage(), PATH_NAME_LEN);
		ptr = strchr(szTemp1, ':');
		if(ptr)
		{
			strncpy(szTemp2, szTemp1, ptr-szTemp1);
		}
		else
			throw e;
		if(!strcmp(szTemp2, "ORA-03113")||!strcmp(szTemp2, "ORA-03114")||!strcmp(szTemp2, "ORA-03135")||!strcmp(szTemp2, "TNS-12571")||!strcmp(szTemp2, "TNS-12570"))
		{
			//数据库链接失败
			m_bDBLinkError = TRUE;
			goto MAINFLOW_REDO;
		}
		throw e;
	}
	catch(...)
	{
		Param.info.msgInfoLog(INFO_BREAK);
		throw jsexcp::CException(errno, "处理文件时遇到未知系统错误", __FILE__, __LINE__);
	}
}

void C_MainFlow::checkTime()
{
	if(chain != NULL)
	{
		//theLog<<"检查是否跨日(check another day)"<<endi;
		MessageParser message;
		ArgMessage argMsg;
		Argument *pMsg = &argMsg;

		char szCurrentTime[DATETIME_LEN+1];
		getCurTime(szCurrentTime);
		if( strncmp(szCurrentTime, m_szLastDay, 8) != 0)
		{
			message.setMessage(MESSAGE_NEW_DAY, "", "", 0);
			argMsg.set(message);
			iRad++;
			if(iRad > 99999)
				iRad = 1;
			argMsg.setTime(szCurrentTime, iRad);
			chain->signal(pMsg);
			strncpy(m_szLastDay, szCurrentTime, 8);
		}
	}
}

void C_MainFlow::process()
{
	CBindSQL ds(DBConn);
	char szSqlStr[SQL_LEN+1];
	char szLogStr[LOG_MSG_LEN+1]; 
	char szTemp[PATH_NAME_LEN+1];
	char szCurrentTime[DATETIME_LEN+1];
	char szTmpPart[2+1];
	int iDBRet=0;

	MessageParser message;
	ArgMessage argMsg;
	Argument *pMsg = &argMsg;
	char szFullInPath[PATH_NAME_LEN+1];	  	//输入路径（全路径）
	char szFullOutPath[PATH_NAME_LEN+1];	//输出路径（全路径）
	char szRealFile[FILE_NAME_LEN+PATH_NAME_LEN+1];
	char szTmpFile[FILE_NAME_LEN+PATH_NAME_LEN+1];
	int iDealCount = 0, iBatchCount = 0;

	vector<SAlterRecordAfterDeal> vecAftDeal;

	if(iUndoFlag == 1 || m_bDBLinkError)
	{
		//发送批次异常消息
		getCurTime(szCurrentTime);
		theLog<<"发送消息：批次异常！"<<endi;
		message.setMessage(MESSAGE_BREAK_BATCH, "", "", 0);
		argMsg.set(message);
		iRad++;
		if(iRad > 99999)
			iRad = 1;
		argMsg.setTime(szCurrentTime, iRad);
		chain->signal(pMsg);
		if(iUndoFlag == 1)
			iUndoFlag++;
		if(m_bDBLinkError)
			m_bDBLinkError = FALSE;
	}
PROC_ENTRY:
	int iFileCount = vecFile.size();
	STmpVariable sVar;
	for(int i =0; i<iFileCount; i++)
	{
		if(vecFile[i].iDealFlag != 0)
		{
			theLog<<"文件"<<vecFile[i].szFileName<<"已处理"<<endi;
			continue;
		}
		//cout<<"文件"<<vecFile[i].szFileName<<"未处理"<<endl;
		getCurTime(vecFile[i].szDealStartTime);
		/* 插入临时变量 */
		strcpy(m_szSourceId, vecFile[i].szSourceId);
		strcpy(m_szLocalTollcode, vecFile[i].szTollcode);
		strcpy(m_szSysTime, vecFile[i].szDealStartTime);
		strcpy(m_szFileName, vecFile[i].szRealFileName);
		strcpy(m_szNewName, vecFile[i].szFileName);
		strcpy(m_szReceiveTime, vecFile[i].szReceiveTime);
		/*
		Param.defaultVar.setDefVar("SOURCE_ID", vecFile[i].szSourceId);
		Param.defaultVar.setDefVar("LOCALTOLL", vecFile[i].szTollcode);
		Param.defaultVar.setDefVar("SYS_TIME", vecFile[i].szDealStartTime);
		Param.defaultVar.setDefVar("FILE_NAME", vecFile[i].szRealFileName);
		Param.defaultVar.setDefVar("NEW_NAME", vecFile[i].szFileName);
		*/
		strcpy(sVar.szVarName, "SOURCE_ID");
		strcpy(sVar.szVarValue, vecFile[i].szSourceId);
		Param.map_DefVar.push_back(sVar);
		strcpy(sVar.szVarName, "LOCALTOLL");
		strcpy(sVar.szVarValue, vecFile[i].szTollcode);
		Param.map_DefVar.push_back(sVar);
		strcpy(sVar.szVarName, "SYS_TIME");
		strcpy(sVar.szVarValue, vecFile[i].szDealStartTime);
		Param.map_DefVar.push_back(sVar);
		strcpy(sVar.szVarName, "FILE_NAME");
		strcpy(sVar.szVarValue, vecFile[i].szRealFileName);
		Param.map_DefVar.push_back(sVar);
		strcpy(sVar.szVarName, "NEW_NAME");
		strcpy(sVar.szVarValue, vecFile[i].szFileName);
		Param.map_DefVar.push_back(sVar);
		strcpy(sVar.szVarName, "RECEIVE_TIME");
		strcpy(sVar.szVarValue, vecFile[i].szReceiveTime);
		Param.map_DefVar.push_back(sVar);

		if(iDealCount == 0 || iBatchCount == 0)
		{
			/* 向插件发出批次开始的消息 */
			getCurTime(szCurrentTime);
			theLog<<"发送消息：批次开始！"<<endi;
			message.setMessage(MESSAGE_NEW_BATCH, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
			argMsg.set(message);
			iRad++;
			if(iRad > 99999)
				iRad = 1;
			argMsg.setTime(szCurrentTime, iRad);
			if(chain == NULL)
			{
				cout<<"chain is null"<<endl;
			}
			chain->signal(pMsg);
		}
		sprintf(szFullInPath, "%s%s", vecFile[i].szSourcePath, Param.szInPath);
		if(Param.bOutputFile)
			sprintf(szFullOutPath, "%s%s", vecFile[i].szSourcePath, Param.szOutPath);
		theLog<<"*************************************************************"<<endi;
		theLog<<"FileName="<<vecFile[i].szRealFileName<<endi;
		theLog<<"InPath="<<szFullInPath<<endi;
		if(Param.bOutputFile)
			theLog<<"OutPath="<<szFullOutPath<<endi;
		theLog<<"SourceId="<<vecFile[i].szSourceId<<endi;
		theLog<<"SourcePath="<<vecFile[i].szSourcePath<<endi;

		/* 向插件发出文件开始的消息 */
		getCurTime(szCurrentTime);
		theLog<<"发送消息：文件开始！"<<endi;
		message.setMessage(MESSAGE_NEW_FILE, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
		argMsg.set(message);
		iRad++;
		if(iRad > 99999)
			iRad = 1;
		argMsg.setTime(szCurrentTime, iRad);
		chain->signal(pMsg);

		//Param.ProcMonitor.UpdateMonitor(vecFile[i].szFileName, 0, 'Y', CProcInfo::SERV_BUSY);
		/* 获取开始处理文件的时间 */
		//getCurTime(vecFile[i].szDealStartTime);
		memset(szTmpPart, 0, sizeof(szTmpPart));
		strncpy(szTmpPart, vecFile[i].szDealStartTime+4, 2);
		vecFile[i].iPartID = atoi(szTmpPart);

		/* 写日志表 */
		/*
		strcpy(szCurrentTime, vecFile[i].szDealStartTime);
		sprintf(szSqlStr, " update %s set deal_flag='H', dealstarttime='%s' where validflag='Y' and filename = '%s' \
			and source_id in(select source_id from C_SOURCE_GROUP_CONFIG where source_group='%s')", \
			Param.szLogTabname, szCurrentTime, vecFile[i].szRealFileName, Param.szSourceGroupId); 
		//theLog<<szSqlStr<<endi;
		ds.Open(szSqlStr, NONSELECT_DML);
		ds.Execute();
		ds.Close();
		*/
		//DBConn.Commit();

		int iRet=0;
		try {
			iRet = DealFile.dealfile(Param, vecFile[i], pps, res);
		} catch (jsexcp::CException &e) {
			sprintf(szLogStr, "处理文件(%s)出错", vecFile[i].szFileName);
			e.PushStack(e.GetAppError(), szLogStr, __FILE__, __LINE__);
			throw e;
		} catch (const std::exception &e) {
			throw jsexcp::CException(1331609, e.what(), __FILE__, __LINE__);
		}

		try
		{
			switch (iRet)
			{
			case 0:
				//处理成功，提交事务
				Param.lack_info.Commit();
				Param.abnormal.Commit();
				if( !strcmp(Param.szIsFmtFirst, "Y") && !strcmp(Param.szFmtErr2Table, "Y") )
					Param.fmt_err2table.Commit();
				iRet = 0;
				/*文件结束*/
				getCurTime(szCurrentTime);
				theLog<<"发送消息：文件结束！"<<endi;
				message.setMessage(MESSAGE_END_FILE, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
				vecAftDeal.clear();
				message.setAlterInfo(&vecAftDeal);
				argMsg.set(message);
				iRad++;
				if(iRad > 99999)
					iRad = 1;
				argMsg.setTime(szCurrentTime, iRad);
				chain->signal(pMsg);
				//Param.lack_info.Close();
				DealFile.endfile(vecAftDeal, Param.info, Param.bOutputFile);
				/*根据删除或备份标志,对输入文件进行处理*/
				char InFileName[FILE_NAME_LEN+1];
				sprintf(InFileName, "%s%s", szFullInPath, vecFile[i].szFileName);
				if(!Param.bBakFlag)
					vecFile[i].iDealFlag = 1;
				iDealCount++;
				iBatchCount++;
				strcpy(m_szLastSource, vecFile[i].szSourceId);
				break;
			case -1: //处理失败，回滚事务，并将文件状态置为“W”
				//处理失败，回滚事务
				Param.lack_info.RollBack();
				Param.abnormal.RollBack();
				if( !strcmp(Param.szIsFmtFirst, "Y") && !strcmp(Param.szFmtErr2Table, "Y") )
					Param.fmt_err2table.RollBack();
				if(DBConn.Rollback()==0)
					theLog<<"Rollback succeed"<<endi;
				else					
					theLog<<"Rollback failed"<<endi;
				/* 向插件发出批次异常的消息 */
				getCurTime(szCurrentTime);
				theLog<<"发送消息：批次异常！"<<endi;
				message.setMessage(MESSAGE_BREAK_BATCH, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
				argMsg.set(message);
				iRad++;
				if(iRad > 99999)
					iRad = 1;
				argMsg.setTime(szCurrentTime, iRad);
				chain->signal(pMsg);
				DealFile.rollback();
				iRet = -1;
				break;
			case -2:  //处理失败，回滚事务，并将文件状态置为“E”
				//处理失败，回滚事务
				theLog<<"处理失败，回滚事务"<<endi;
				Param.lack_info.RollBack();
				Param.abnormal.RollBack();
				if( !strcmp(Param.szIsFmtFirst, "Y") && !strcmp(Param.szFmtErr2Table, "Y") )
					Param.fmt_err2table.RollBack();
				if(DBConn.Rollback()==0)
					theLog<<"Rollback succeed"<<endi;
				else					
					theLog<<"Rollback failed"<<endi;
				/* 日志表文件置E */
				sprintf(szSqlStr, "update %s a set deal_flag='E' where proc_index = %d and filename = '%s' and \
					exists (select source_id from C_SOURCE_GROUP_CONFIG b where a.source_id = b.source_id and \
					b.source_group='%s') and partid in (%d,%d,%d)", Param.szLogTabname, Param.iProcessId,
					vecFile[i].szRealFileName, Param.szSourceGroupId, getPrePartID(vecFile[i].iPartID),
					vecFile[i].iPartID, getNextPartID(vecFile[i].iPartID));
				//theLog<<szSqlStr<<endi;
				ds.Open(szSqlStr, NONSELECT_DML);
				ds.Execute();
				ds.Close();
				if(DBConn.Commit()==0)
					theLog<<"Commit succeed"<<endi;
				else					
					theLog<<"Commit failed"<<endi;
				vecFile[i].iDealFlag = 3;
				/* 向插件发出批次异常的消息 */
				getCurTime(szCurrentTime);
				theLog<<"发送消息：批次异常！"<<endi;
				message.setMessage(MESSAGE_BREAK_BATCH, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
				argMsg.set(message);
				iRad++;
				if(iRad > 99999)
					iRad = 1;
				argMsg.setTime(szCurrentTime, iRad);
				chain->signal(pMsg);
				DealFile.rollback();
				/* 同批次中已处理的文件状态置为未处理 */
				for(int j=0; j<i; j++)
				{
					if(vecFile[j].iDealFlag == 1)
					{
						theLog<<"文件"<<vecFile[i].szFileName<<"状态置为W"<<endi;
						vecFile[j].iDealFlag = 0;
					}
				}
				i = 0;
				goto PROC_ENTRY;
			default:
				iRet = -100;
				//其他，一般不会发生
			}//end of switch
			if( i<(iFileCount-1)  ) 
			{
				if( !strcmp(vecFile[i].szSourceId,vecFile[i+1].szSourceId) && iDealCount<vecFile[i].iMaxCount )
				{
					/* 下个文件的SourceId和当前文件的相同 */
					continue;
				}
			}
			/* 向插件发出批次结束：提交文件的消息 */
			getCurTime(szCurrentTime);
			theLog<<"发送消息：批次结束，准备提交！"<<endi;
			message.setMessage(MESSAGE_END_BATCH_END_FILES, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
			argMsg.set(message);
			iRad++;
			if(iRad > 99999)
				iRad = 1;
			argMsg.setTime(szCurrentTime, iRad);
			chain->signal(pMsg);
			/* 提交 */
			Param.classify.commit();
			/* 向插件发出批次结束：提交数据库的消息 */
			getCurTime(szCurrentTime);
			theLog<<"发送消息：批次结束，提交数据库！"<<endi;
			message.setMessage(MESSAGE_END_BATCH_END_DATA, vecFile[i].szSourceId, vecFile[i].szRealFileName, vecFile[i].lFileId);
			argMsg.set(message);
			iRad++;
			if(iRad > 99999)
				iRad = 1;
			argMsg.setTime(szCurrentTime, iRad);
			chain->signal(pMsg);
			if(DBConn.Commit()==0)
				theLog<<"Commit succeed"<<endi;
			else					
				theLog<<"Commit failed"<<endi;
			iBatchCount=0;
			/* 根据备份标志是否删除文件 */
			DealFile.commit(Param.bOutputFile);
			if(!Param.bBakFlag)
			{
				for(int j=0; j<=i; j++)
				{
					if(vecFile[j].iDealFlag == 1)
					{
						sprintf(szTemp, "%s%s", szFullInPath, vecFile[j].szFileName);
						theLog<<"unlink "<<szTemp<<endi;
						unlink(szTemp);
						vecFile[j].iDealFlag = 2;
					}
				}
			}
			/* 提交 */
			//theLog<<"批次提交"<<endi;
			
			vecFile.clear();
			//delete pMsg;
			/*
			if(Param.bCommemFlag)
				memManager->printTime();
				*/
		}//end of try
		catch (jsexcp::CException &e) 
		{
			if(DBConn.Rollback()==0)
				theLog<<"Rollback succeed"<<endi;
			else					
				theLog<<"Rollback failed"<<endi;
			sprintf(szLogStr, "分析文件(%s)的处理结果出错", vecFile[i].szFileName);
			e.PushStack(e.GetAppError(), szLogStr, __FILE__, __LINE__);
			throw e;
		} 
		catch (const std::exception &e) 
		{
			if(DBConn.Rollback()==0)
				theLog<<"Rollback succeed"<<endi;
			else					
				theLog<<"Rollback failed"<<endi;
			throw jsexcp::CException(1331609, e.what(), __FILE__, __LINE__);
		}
		catch(...)
		{
			if(DBConn.Rollback()==0)
				theLog<<"Rollback succeed"<<endi;
			else					
				theLog<<"Rollback failed"<<endi;
			throw jsexcp::CException(errno, "未知系统错误", __FILE__, __LINE__);
		}
	}//end of for

}

void C_MainFlow::resetHFiles()
{
	char szSqlStr[SQL_LEN+1];
	//日志表中是否有上次退出时未完成的H文件
	CBindSQL ds(DBConn);
	sprintf(szSqlStr, " update %s set deal_flag='W' where deal_flag='H' and validflag='Y' and \
		proc_index = %d and source_id in(select source_id from C_SOURCE_GROUP_CONFIG \
		where source_group='%s')", Param.szLogTabname, Param.iProcessId, Param.szSourceGroupId);
	//theLog<<szSqlStr<<endi;
	ds.Open(szSqlStr, NONSELECT_DML);
	ds.Execute();
	ds.Close();
	if(DBConn.Commit()==0)
		theLog<<"Commit succeed"<<endi;
	else
		theLog<<"Commit failed"<<endi;
}

//返回值：-1	失败
//        0		成功
//		  >0	文件个数
int C_MainFlow::getFilesFromDB()
{
	CBindSQL ds(DBConn);

	char szSqlStr[SQL_LEN+1];
	char szLogStr[LOG_MSG_LEN+1]; 
	char szTemp[FIELD_LEN+1];
	char szTmpPart[2+1];
	char szCurrentTime[DATETIME_LEN+1];
	int iRet;
	SFileStruct FileStruct;
	
	memset(szCurrentTime, 0, sizeof(szCurrentTime));
	getCurTime(szCurrentTime);
	memset(szTmpPart, 0, sizeof(szTmpPart));
	strncpy(szTmpPart, szCurrentTime+4, 2);

	try
	{
		/* 从数据库读日志表中的H文件 */
		int iFileCount = 0; //待处理文件个数
		sprintf(szSqlStr, "select count(*) from %s a, C_SOURCE_GROUP_CONFIG b where a.source_id= b.source_id \
		  and a.deal_flag='W' and a.validflag='Y' and a.proc_index = %d and a.partid in(%d,%d,%d) \
		  and b.source_group='%s'", Param.szLogTabname, Param.iProcessId, getPrePartID(szTmpPart), atoi(szTmpPart),
		  getNextPartID(szTmpPart), Param.szSourceGroupId);
		ds.Open(szSqlStr, SELECT_QUERY );
		//cout<<szSqlStr<<endl;
		ds>>iFileCount;
		ds.Close();
		if (iFileCount > 0)
		{
			iUndoFlag ++;
			//iFileCount = iFileCount > Param.iMaxNum ? Param.iMaxNum: iFileCount;
			//cout<<"iFileCount="<<iFileCount<<endl;
			memset(szTemp, 0, sizeof(szTemp));
			/*　从库表中读入待处理文件的信息　*/
			sprintf(szSqlStr, "select filename, a.source_id from %s a, C_SOURCE_GROUP_CONFIG b where a.source_id= b.source_id \
			and a.deal_flag='W' and a.validflag='Y' and a.proc_index = %d and b.source_group='%s' and partid in (%d,%d,%d)",
			Param.szLogTabname, Param.iProcessId, Param.szSourceGroupId, getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
			ds.Open(szSqlStr, SELECT_QUERY );
			for (int i=0; i<iFileCount; i++)
			{
				memset(&FileStruct, 0, sizeof(FileStruct));
				if (!(ds>>FileStruct.szFileName>>FileStruct.szSourceId))
				{
					ds.Close();
					strcpy(szLogStr, "the information in the source table  are not correct,please check ! ");
					theLog<<szLogStr<<endd;
					return -1;
				}
				else
				{
					if (FileStruct.szSourcePath[strlen(FileStruct.szSourcePath)-1] != '/')
						strcat(FileStruct.szSourcePath, "/");
					//strncpy(FileStruct.szRealFileName, FileStruct.szFileName, strrchr(FileStruct.szFileName,'.')-FileStruct.szFileName);
					strcpy(FileStruct.szRealFileName, FileStruct.szFileName);
					sprintf(FileStruct.szFileName, "%s.%d", FileStruct.szRealFileName, Param.iProcessId);
					if(getFileInfo( FileStruct ))
					{
					  theLog<<"准备处理("<<FileStruct.szRealFileName<<")"<<endi;
					  vecFile.push_back( FileStruct );
					}
					else
						theLog<<"文件"<<FileStruct.szRealFileName<<"重复！"<<endw;
				}
			}
			ds.Close();
  	
			return iFileCount;
		}
		return -1;
	}
	catch(jsexcp::CException &e) 
	{
		//errLog(ERR_GET_FILE, "从队列读取待处理文件出错", e.GetAppError(), e.GetErrMessage(), __FILE__, __LINE__);
		e.PushStack(ERR_GET_FILE, "从队列读取待处理文件出错", __FILE__, __LINE__);
		throw e;
	}
	catch(...)
	{
		throw jsexcp::CException(errno, "从队列读取待处理文件出错", __FILE__, __LINE__);
		//theLog<<"exit :"<<errno<<ende;
	}
}


//返回值：-1	失败
//        0		成功
//		  >0	文件个数
int C_MainFlow::getFilesFromPPQ()
{
	CBindSQL ds(DBConn);

	char szSqlStr[SQL_LEN+1];
	char szLogStr[LOG_MSG_LEN+1]; 
	char szTemp[FIELD_LEN+1];
	char szCurrentTime[DATETIME_LEN+1];
	char szRealFile[FILE_NAME_LEN+PATH_NAME_LEN+1];
	char szTmpFile[FILE_NAME_LEN+PATH_NAME_LEN+1];
	int iRet;
	SFileStruct FileStruct;
	int iFileCount=0;
	
	/* 从队列读取待处理文件 */ 
	theLog<<"从队列读取待处理文件……"<<endd;
	try
	{
		if(nextBatch.size() > 0)
		{
			for(int i=0; i<nextBatch.size(); i++)
			{
				vecFile.push_back( nextBatch[i] );
				iFileCount++;
			}
			nextBatch.clear();
			if(iFileCount >= vecFile[vecFile.size()-1].iMaxCount)
			{
				return iFileCount;
			}
		}
		CMessage respMsg;
		char szFileCnt[128];
		char szFileCntFieldName[32];
		//for(int i=0; i<Param.iMaxNum; i++)
		while(1)
		{
			Param.ProcMonitor.UpdateMonitor(CProcInfo::SERV_WAIT);
			memset(&FileStruct, 0, sizeof(FileStruct));
			memset(szTmpFile, 0,sizeof(szTmpFile));
			//get a response message from the request_message_queue
			if( respMsgHandle.PopMsg(respMsg) != 0 )
			{
				theLog << "接收被SIGALRM中断" << endi;
				break;
			}
			Param.ProcMonitor.UpdateMonitor(CProcInfo::SERV_BUSY);
			iFileCount++;
			respMsgHandle.GetMsgQHead(0, szFileCntFieldName, szFileCnt);
			strcpy(szTmpFile, respMsg.GetMsgTxt());
			strncpy(FileStruct.szRealFileName, szTmpFile, strlen(szTmpFile)-2);
			sprintf(FileStruct.szFileName, "%s.%d", FileStruct.szRealFileName, Param.iProcessId);
			strcpy(FileStruct.szSourceId, respMsg.GetSrcID());
			/* 从数据库读取文件信息 */
			if(!getFileInfo( FileStruct, true ))
			{
				theLog<<"文件"<<FileStruct.szRealFileName<<"重复！"<<endw;
				continue;
			}
			if(vecFile.size() > 0)
			{
				if(strcmp(vecFile[vecFile.size()-1].szSourceId, FileStruct.szSourceId))
				{
					//需要换批次
					//cout<<">>>最后执行的文件source是:"<<m_szLastSource<<endl;
					theLog<<"下一次处理("<<FileStruct.szRealFileName<<")"<<endi;
					nextBatch.push_back( FileStruct );
					break;
				}
			}
			theLog<<"准备处理("<<FileStruct.szRealFileName<<")"<<endi;
			//DEBUG_LOG<<"准备处理("<<FileStruct.szRealFileName<<")"<<endd;
			vecFile.push_back( FileStruct );
			if(iFileCount >= vecFile[vecFile.size()-1].iMaxCount)
			{
				break;
			}
		}//end while
	}//end of try
	catch (jsexcp::CException &e) 
	{
		if(!(bGetExitSig && e.GetAppError()==ERR_SEMAPHORE_OPER_FAILED))
		{
			e.PushStack(ERR_GET_FILE, "从队列读取待处理文件出错", __FILE__, __LINE__);
			throw e;
		}
	}
	catch(...)
	{
		throw jsexcp::CException(errno, "从队列读取待处理文件出错", __FILE__, __LINE__);
		//theLog<<"exit :"<<errno<<ende;
	}
	return iFileCount;
}

void C_MainFlow::getSourceInfo()
{
	CBindSQL ds(DBConn);
	char szSqlStr[SQL_LEN+1];
	memset(szSqlStr, 0, sizeof(szSqlStr));
	SSourceStruct source;

	sprintf(szSqlStr, "select a.source_id, a.source_path, a.tollcode, a.serv_cat_id, a.file_fmt, to_number(b.priority) \
		from i_source_define a, c_source_batch b, c_source_group_config c where a.source_id=b.source_id and a.source_id=c.source_id \
		and b.service='%s' and c.source_group = '%s'", Param.szServiceId, Param.szSourceGroupId);
	ds.Open(szSqlStr, SELECT_QUERY);
	while(ds>>source.szSourceId>>source.szSourcePath>>source.szTollcode>>source.szServCat
		>>source.szSourceFiletype>>source.iMaxCount)
	{
		if(source.szSourcePath[strlen(source.szSourcePath)-1] != '/')
			strcat(source.szSourcePath, "/");
		mapSource.insert(pair<string, SSourceStruct>(string(source.szSourceId), source));
	}
	ds.Close();
}

bool C_MainFlow::getFileInfo(struct SFileStruct &FileStruct, bool bNewFile)
{
	char szRealFile[FILE_NAME_LEN+PATH_NAME_LEN+1];
	char szTmpFile[FILE_NAME_LEN+PATH_NAME_LEN+1];
	char szLogStr[LOG_MSG_LEN+1];
	char szSqlStr[SQL_LEN+1];
	char szCurrentTime[14+1];
	char szTmpPart[2+1];
	CBindSQL ds(DBConn);
	int iCount =0;
	
	memset(szCurrentTime, 0, sizeof(szCurrentTime));
	getCurTime(szCurrentTime);
	memset(szTmpPart, 0, sizeof(szTmpPart));
	strncpy(szTmpPart, szCurrentTime+4, 2);

	try
	{
		if(FileStruct.szSourcePath[strlen(FileStruct.szSourcePath)-1] != '/')
			strcat(FileStruct.szSourcePath, "/"); 
		map<string, SSourceStruct>::iterator it;
		if( bNewFile )
		{
			//检查SCH是否已该文件
			sprintf(szSqlStr, "select count(*) from %s where source_id = '%s' and filename = '%s' and \
			  partid in (%d,%d,%d)", Param.szLogTabname, FileStruct.szSourceId, FileStruct.szRealFileName,
			  getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
			ds.Open(szSqlStr, SELECT_QUERY);
			if(!(ds>>iCount))
			{
				ds.Close();
				sprintf(szLogStr,"执行 %s 出错！",szSqlStr);
				throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
			}
			ds.Close();
			if(iCount > 0)
			{
			  printf(szSqlStr, "update %s set deal_flag='D' where source_id='%s' and filename='%s' and \
				  partid in (%d,%d,%d)", Param.szLogTabname, FileStruct.szSourceId, FileStruct.szRealFileName,
				  getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
			  ds.Open(szSqlStr, NONSELECT_DML);
			  ds.Execute();
			  ds.Close();
			  if(DBConn.Commit()==0)
			  	theLog<<"Commit succeed"<<endi;
			  else
			  	theLog<<"Commit failed"<<endi;
			  return false;
			}
			//cout<<FileStruct.szSourceId<<endl;
			it = mapSource.find( string(FileStruct.szSourceId) );
			if(it == mapSource.end())
			{
				/* 先插入日志表再抛异常 */
				sprintf(szSqlStr, "insert into %s(source_id, serv_cat_id, filename, deal_flag, validflag, proc_index, \
				  dealstarttime) values('%s', '00', '%s', 'E', 'Y', %d, '%s')",  Param.szLogTabname, 
				  FileStruct.szSourceId, FileStruct.szRealFileName, Param.iProcessId, szCurrentTime);
				ds.Open(szSqlStr, NONSELECT_DML);
				ds.Execute();
				ds.Close();
			  if(DBConn.Commit()==0)
			  	theLog<<"Commit succeed"<<endi;
			  else
			  	theLog<<"Commit failed"<<endi;
				sprintf(szLogStr,"找不到数据源 %s 的信息！",FileStruct.szSourceId);
				throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
			}
			/* 将读入的文件信息插入日志表 */
			memset(szSqlStr, 0, sizeof(szSqlStr));
			sprintf(szSqlStr, "insert into %s(source_id, serv_cat_id, filename, deal_flag, validflag, proc_index, \
			  dealstarttime) values('%s', '%s', '%s', 'W', 'Y', %d, '%s')",  Param.szLogTabname, 
			  FileStruct.szSourceId, (it->second).szServCat, FileStruct.szRealFileName, Param.iProcessId,
			  szCurrentTime);
			ds.Open(szSqlStr, NONSELECT_DML);
			ds.Execute();
			ds.Close();
			//if (FileStruct.szSourcePath[strlen(FileStruct.szSourcePath)-1] != '/')
			//	strcat(FileStruct.szSourcePath, "/");
			sprintf(szRealFile, "%s%s%s.0", (it->second).szSourcePath, Param.szInPath, FileStruct.szRealFileName);
			sprintf(szTmpFile, "%s%s%s.%d", (it->second).szSourcePath, Param.szInPath, FileStruct.szRealFileName, Param.iProcessId);	
			sprintf(FileStruct.szFileName, "%s.%d", FileStruct.szRealFileName, Param.iProcessId);
			DEBUG_LOG<<"将文件 ("<<szRealFile<<") 改名成 ("<<szTmpFile<<")"<<endd;
			/* 文件改名 */
			if(rename(szRealFile, szTmpFile) != 0 )
			{
				//先改文件状态再抛异常
				sprintf(szSqlStr, "update %s set deal_flag='E' where source_id='%s' and filename='%s' and \
					partid in (%d,%d,%d)", Param.szLogTabname, FileStruct.szSourceId, FileStruct.szRealFileName,
					getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
				ds.Open(szSqlStr, NONSELECT_DML);
				ds.Execute();
				ds.Close();
			  if(DBConn.Commit()==0)
			  	theLog<<"Commit succeed"<<endi;
			  else
			  	theLog<<"Commit failed"<<endi;
				sprintf(szLogStr,"将文件 %s 改名成 %s 出错！",szRealFile, szTmpFile);
				throw jsexcp::CException(PREDEAL_ERR_PK_DUPLICATE, szLogStr, __FILE__, __LINE__);
			}
			/* 读入其他信息 */
			strcpy(FileStruct.szSourcePath, (it->second).szSourcePath);
			strcpy(FileStruct.szTollcode, (it->second).szTollcode);
			strcpy(FileStruct.szServCat, (it->second).szServCat);
			strcpy(FileStruct.szSourceFiletype, (it->second).szSourceFiletype);
			FileStruct.iMaxCount = (it->second).iMaxCount;
			if(DBConn.Commit()==0)
			 	theLog<<"Commit succeed"<<endi;
			else
			 	theLog<<"Commit failed"<<endi;
		}
		else
		{
			it = mapSource.find( string(FileStruct.szSourceId) );
			if(it == mapSource.end())
			{
				sprintf(szLogStr,"找不到数据源 %s 的信息！",FileStruct.szSourceId);
				throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
			}
			strcpy(FileStruct.szSourcePath, (it->second).szSourcePath);
			strcpy(FileStruct.szTollcode, (it->second).szTollcode);
			strcpy(FileStruct.szServCat, (it->second).szServCat);
			strcpy(FileStruct.szSourceFiletype, (it->second).szSourceFiletype);
		}
		/*　从库表中读入待处理文件的信息　*/
		/*
		sprintf(szSqlStr, "select source_path, tollcode, serv_cat_id, file_fmt from i_source_define where source_id='%s'", 
			FileStruct.szSourceId);
		ds.Open(szSqlStr, SELECT_QUERY );
		if(!(ds>>FileStruct.szSourcePath>>FileStruct.szTollcode>>FileStruct.szServCat>>FileStruct.szSourceFiletype))
		{
			ds.Close();
			sprintf(szLogStr, "读取%s文件信息失败！", FileStruct.szRealFileName);
			throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
			//theLog<<"读取文件信息失败！"<<ende;
			//exit (-1);;
		}
		*/
		/* 有格式化插件时读文件的ID */
		if(!strcmp(Param.szIsFmtFirst, "Y"))
		{
			sprintf(szSqlStr, "select nvl(file_id,-1), receive_time from D_FILE_RECEIVED where Source_Id='%s' and service='%s' \
			  and FileName='%s' and partid in (%d,%d,%d)",  FileStruct.szSourceId, Param.szServiceId,
			  FileStruct.szRealFileName, getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
			ds.Open(szSqlStr, SELECT_QUERY );
			if(!(ds>>FileStruct.lFileId>>FileStruct.szReceiveTime))
			{
				ds.Close();
				sleep(1);
				ds.Open(szSqlStr, SELECT_QUERY );
				if(!(ds>>FileStruct.lFileId>>FileStruct.szReceiveTime))
				{
					ds.Close();
					sprintf(szLogStr, "读取%s文件ID失败！", FileStruct.szRealFileName);
					throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
				}
			}
			ds.Close();
		}
		else
		{
			/* 读文件接收时间 */
			sprintf(szSqlStr, "select receive_time from D_FILE_RECEIVED where Source_Id='%s' and service='%s' \
			  and FileName='%s' and partid in (%d,%d,%d)",  FileStruct.szSourceId, Param.szServiceId,
			  FileStruct.szRealFileName, getPrePartID(szTmpPart), atoi(szTmpPart), getNextPartID(szTmpPart));
			ds.Open(szSqlStr, SELECT_QUERY );
			if(!(ds>>FileStruct.szReceiveTime))
			{
				ds.Close();
				sleep(1);
				ds.Open(szSqlStr, SELECT_QUERY );
				if(!(ds>>FileStruct.szReceiveTime))
				{
					ds.Close();
					sprintf(szLogStr, "读取%s文件接收时间失败！", FileStruct.szRealFileName);
					throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
				}
			}
			ds.Close();
		}
		
		return true;
	}
	catch(jsexcp::CException &e) 
	{
		//errLog(ERR_GET_FILE, "从队列读取待处理文件出错", e.GetAppError(), e.GetErrMessage(), __FILE__, __LINE__);
		e.PushStack(ERR_GET_FILE, "读取文件信息出错", __FILE__, __LINE__);
		throw e;
	}
	catch(...)
	{
		throw jsexcp::CException(errno, "读取文件信息出错", __FILE__, __LINE__);
		//theLog<<"exit :"<<errno<<ende;
	}
}

char* C_MainFlow::getMsgKey(CReadIni &IniFile, char *szServiceId, char *szSourceGroupId)
{
	char szMsgList[STR_LEN+1];
	IniFile.GetValue("MSGQ_LIST", "resp_list", szMsgList, 'N');
	char szServiceCheck[MAXLENGTH+1];
	char szSourceGroupCheck[MAXLENGTH+1];
	char szMsgKey[11];
	char tmp[11];
	char *ss0,*ss1;
	ss0 = szMsgList;
	while(( ss1 = strchr( ss0,',' ) ) != NULL)
	{
		*ss1 = 0;
		strcpy(tmp, ss0);
		ss0 = ss1+1;
		*ss1 = ',';
		strcpy(szMsgKey, tmp);
		IniFile.GetValue(szMsgKey, "service_name", szServiceCheck, 'N');
		IniFile.GetValue(szMsgKey, "source_group", szSourceGroupCheck, 'N');
		if( !strcmp(szServiceId, szServiceCheck) && !strcmp(szSourceGroupId, szSourceGroupCheck) )
			return szMsgKey;
	} 
	strcpy(tmp ,ss0);
	strcpy(szMsgKey, tmp);
	IniFile.GetValue(szMsgKey, "service_name", szServiceCheck, 'N');
	IniFile.GetValue(szMsgKey, "source_group", szSourceGroupCheck, 'N');
	if( !strcmp(szServiceId, szServiceCheck) && !strcmp(szSourceGroupId, szSourceGroupCheck) )
		return szMsgKey;
	else
		throw jsexcp::CException(0, "找不到相关的文件队列！", __FILE__, __LINE__);
}

/***********************************************************************************
*从数据库中获取变量名对应的值
***********************************************************************************/
int C_MainFlow::getScheme(struct SParameter &Param)
{
	char szLogStr[LOG_MSG_LEN+1];             //日志信息
	char szSqlStr[SQL_LEN+1];
	char szTemp[FIELD_LEN+1];

	CBindSQL ds(DBConn);

	/*获取插件文件所在路径*/
	memset( Param.szSlPath, 0, sizeof(Param.szSlPath) );
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "PLUGIN_PATH", Param.szSlPath ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='PLUGIN_PATH'的项" );
		theLog<<szLogStr<<endi;
		return -1;
	} 
	theLog<<"PLUGIN_PATH="<<Param.szSlPath<<endd;
	/* 获取插件文件名 */
	memset( Param.szSlName, 0, sizeof(Param.szSlName) );
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "PLUGIN_NAME", Param.szSlName ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='PLUGIN_NAME'的项" );
		theLog<<szLogStr<<endi;
		return -1;
	}
	theLog<<"PLUGIN_NAME="<<Param.szSlName<<endd;
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "COMMON_LACKINFO_SAVE_CONFIG", Param.szLackSaveTableId ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='COMMON_LACKINFO_SAVE_CONFIG'的项");
		theLog<<szLogStr<<endi;
		return -1;
	}
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "COMMON_LACKINFO_STAT_CONFIG", Param.szLackStatTableId ) == -1 )
	{
		memset(Param.szLackStatTableId, 0, sizeof(Param.szLackStatTableId));
	}
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "COMMON_ABNORMAL_SAVE_CONFIG", Param.szAbnSaveTableId ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='COMMON_ABNORMAL_SAVE_CONFIG'的项");
		theLog<<szLogStr<<endi;
		return -1;
	}
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "COMMON_ABNORMAL_STAT_CONFIG", Param.szAbnStatTableId ) == -1 )
	{
		memset(Param.szAbnStatTableId, 0, sizeof(Param.szAbnStatTableId));
	}
	memset(szTemp, 0, sizeof(szTemp));
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "CONNECT_COMMEM_FLAG", szTemp ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='CONNECT_COMMEM_FLAG'的项");
		theLog<<szLogStr<<endi;
		return -1;
	}
	if(!strcmp(szTemp, "Y"))
		Param.bCommemFlag = true;
	else if(!strcmp(szTemp, "N"))
		Param.bCommemFlag = false;
	else
	{
		sprintf(szLogStr, "环境变量表中 VARNAME='CONNECT_COMMEM_FLAG' 的配置 %s 不正确！", szTemp);
		theLog<<szLogStr<<endi;
		return -1;
	}
	theLog<<"CONNECT_COMMEM_FLAG="<<szTemp<<endd;
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "IS_FMT_FIRST", Param.szIsFmtFirst ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='IS_FMT_FIRST'的项");
		theLog<<szLogStr<<endi;
		return -1;
	}
	theLog<<"IS_FMT_FIRST="<<Param.szIsFmtFirst<<endd;
	if(!strcmp(Param.szIsFmtFirst, "Y"))
	{
		/* 有格式化时 */
		
		/* 格式化错单的处理情况 */
		if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_ERR_W_TABLE", Param.szFmtErr2Table ) == -1 )
		{
			sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_ERR_W_TABLE'的项");
			theLog<<szLogStr<<endi;
			return -1;
		}
		theLog<<"FMT_ERR_W_TABLE="<<Param.szFmtErr2Table<<endd;
		if(strncmp(Param.szFmtErr2Table, "Y", 1) == 0)
		{
			/*获取无资料记录表和无资料统计表的ID*/
			memset( Param.szFmtErrSaveTableId, 0, sizeof(Param.szFmtErrSaveTableId) );
			if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_ERR_SAVE_CONFIG", Param.szFmtErrSaveTableId ) == -1 )
			{
				sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_ERR_SAVE_CONFIG'的项" );
				theLog<<szLogStr<<endi;
				return -1;
			} 
			theLog<<"FMT_ERR_SAVE_CONFIG="<<Param.szFmtErrSaveTableId<<endd;
			memset( Param.szFmtErrStatTableId, 0, sizeof(Param.szFmtErrStatTableId) );
			if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_ERR_STAT_CONFIG", Param.szFmtErrStatTableId ) == -1 )
			{
				/*
				sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_ERR_STAT_CONFIG'的项" );
				theLog<<szLogStr<<endi;
				return -1;
				*/
				memset( Param.szFmtErrStatTableId, 0, sizeof(Param.szFmtErrStatTableId) );
			}
			else
				theLog<<"FMT_ERR_STAT_CONFIG="<<Param.szFmtErrStatTableId<<endd;
		}
		if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_ERR_W_OUTFILE", Param.szFmtErr2File ) == -1 )
		{
			sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_ERR_W_OUTFILE'的项");
			theLog<<szLogStr<<endi;
			return -1;
		}
		theLog<<"FMT_ERR_W_OUTFILE="<<Param.szFmtErr2File<<endd;
		if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_ERR_DIR", Param.szFmtErrDir ) == -1 )
		{
			sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_ERR_DIR'的项");
			theLog<<szLogStr<<endi;
			return -1;
		}
		if(Param.szFmtErrDir[strlen(Param.szFmtErrDir)-1] != '/')
			strcat(Param.szFmtErrDir, "/");
		theLog<<"FMT_ERR_DIR="<<Param.szFmtErrDir<<endd;
		if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_TIMEOUT_DIR", Param.szFmtTimeOutDir ) == -1 )
		{
			sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_TIMEOUT_DIR'的项");
			theLog<<szLogStr<<endi;
			return -1;
		}
		if(Param.szFmtTimeOutDir[strlen(Param.szFmtTimeOutDir)-1] != '/')
			strcat(Param.szFmtTimeOutDir, "/");
		theLog<<"FMT_TIMEOUT_DIR="<<Param.szFmtTimeOutDir<<endd;
		if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "FMT_OTHER_DIR", Param.szFmtOtherDir ) == -1 )
		{
			sprintf(szLogStr, "环境变量表中找不到VARNAME='FMT_OTHER_DIR'的项");
			theLog<<szLogStr<<endi;
			return -1;
		}
		if(Param.szFmtOtherDir[strlen(Param.szFmtOtherDir)-1] != '/')
			strcat(Param.szFmtOtherDir, "/");
		theLog<<"FMT_OTHER_DIR="<<Param.szFmtOtherDir<<endd;
	}//end of fmt first
	memset(szTemp, 0, sizeof(szTemp));
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "SERV_CAT_CONFIG", szTemp ) == -1 )
	{
		sprintf(szLogStr, "环境变量表中找不到VARNAME='SERV_CAT_CONFIG'的项");
		theLog<<szLogStr<<endi;
		return -1;
	}
	Param.iServCatConfig=atoi(szTemp);
	theLog<<"SERV_CAT_CONFIG="<<Param.iServCatConfig<<endd;
	memset(szTemp, 0, sizeof(szTemp));
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "OUTPUT_FILE", szTemp ) == -1 )
	{
		strcpy(szTemp, "Y");
	}
	if(!strcmp(szTemp, "Y"))
		Param.bOutputFile = true;
	else
		Param.bOutputFile = false;
	theLog<<"OUTPUT_FILE="<<Param.bOutputFile<<endd;

	memset(szTemp, 0, sizeof(szTemp));
	if( getEnvFromDB( DBConn, Param.szServiceId, Param.szSourceGroupId, "", "INFILE_BAK_FLAG", szTemp ) == -1 )
	{
		strcpy(szTemp, "N");
	}
	if(!strcmp(szTemp, "Y"))
		Param.bBakFlag = true;
	else if(!strcmp(szTemp, "N"))
		Param.bBakFlag = false;
	else
	{
		sprintf(szLogStr, "环境变量表中 VARNAME='INFILE_BAK_FLAG' 的配置 %s 不正确！", szTemp);
		theLog<<szLogStr<<endi;
		return -1;
	}
	theLog<<"INFILE_BAK_FLAG="<<szTemp<<endd;

	/***********************************************************************
	/*  查询工作流模板ID（workflow_id）
	/***********************************************************************/
	sprintf(szSqlStr, "select server_id, workflow_id, filetype_id from c_source_group_define where source_group='%s'", Param.szSourceGroupId);
	ds.Open(szSqlStr, SELECT_QUERY );
	if(!(ds>>Param.szServerId>>Param.szWorkflowId>>Param.szOutputFiletypeId))
	{
		throw jsexcp::CException(0, "找不到工作流的配置", __FILE__, __LINE__);
	}
	ds.Close();
	/* 查询输入输出控制表名和路径 */
	sprintf(szSqlStr, "select a.log_tabname, a.work_path from c_service_interface a, c_service_flow b \
		where a.interface_id=b.input_id and b.workflow_id='%s' and b.service='%s'", Param.szWorkflowId, Param.szServiceId);
	ds.Open(szSqlStr, SELECT_QUERY);
	if(!(ds>>Param.szLogTabname>>Param.szInPath))
	{
		throw jsexcp::CException(0, "找不到工作流的配置", __FILE__, __LINE__);
	}
	ds.Close();
	if(Param.szInPath[strlen(Param.szInPath)-1] != '/')
		strcat(Param.szInPath, "/");
	ds.Open("select a.input_path from c_service_interface a, c_service_flow b where \
		a.interface_id=b.output_id and b.workflow_id=:v1 and b.service=:v2", SELECT_QUERY);
	ds<<Param.szWorkflowId<<Param.szServiceId;
	if(!(ds>>Param.szOutPath))
	{
		if(Param.bOutputFile)
			throw jsexcp::CException(0, "找不到工作流的配置", __FILE__, __LINE__);
	}
	ds.Close();
	if(Param.bOutputFile)
	{
		if(Param.szOutPath[strlen(Param.szOutPath)-1] != '/')
			strcat(Param.szOutPath, "/");
	}

	/* 获得输出文件类型 */
	theLog<<"szOutputFiletypeId="<<Param.szOutputFiletypeId<<endd;
	/* 获取输出记录类型 */
	ds.Open("select record_type from c_filetype_define where filetype_id=:v1", SELECT_QUERY );
	ds<<Param.szOutputFiletypeId;
	if (!(ds>>Param.szOutrcdType))
	{
		sprintf(szLogStr, "在表C_FILETYPE_DEFINE中找不到 %s 的配置", Param.szOutputFiletypeId);
		//theLog<<szLogStr<<endi;
		throw jsexcp::CException(0, szLogStr, __FILE__, __LINE__);
		//return -1;
	}
	ds.Close();
	sprintf(szSqlStr, "select interval from c_process_ctl where source_group = '%s' AND service = '%s'", Param.szSourceGroupId, Param.szServiceId);
	ds.Open(szSqlStr, SELECT_QUERY );
	if(!(ds>>szTemp))
	{
		throw jsexcp::CException(0, "找不到sleeptime的配置", __FILE__, __LINE__);
	}
	ds.Close();
	Param.iSleepTime = atoi(szTemp);
	theLog<<"SleepTime="<<Param.iSleepTime<<endd;

	return 0;
}

void C_MainFlow::exit()
{
	if(chain != NULL)
	{
		//cout<<"send message quit"<<endl;
		MessageParser message;
		ArgMessage argMsg;
		Argument *pMsg = &argMsg;

		char szCurrentTime[DATETIME_LEN+1];
		getCurTime(szCurrentTime);
		message.setMessage(MESSAGE_PROGRAM_QUIT, "", "", 0);
		argMsg.set(message);
		iRad++;
		if(iRad > 99999)
			iRad = 1;
		argMsg.setTime(szCurrentTime, iRad);
		chain->signal(pMsg);
	}
	Param.ProcMonitor.UpdateMonitor(CProcInfo::SERV_EXIT);
	Param.info.msgInfoLog(INFO_QUIT);
}

bool C_MainFlow::DBLinkError()
{
	return m_bDBLinkError;
}

void C_MainFlow::resetAll()
{
	if(chain != NULL)
	{
		MessageParser message;
		ArgMessage argMsg;
		Argument *pMsg = &argMsg;

		char szCurrentTime[DATETIME_LEN+1];
		getCurTime(szCurrentTime);
		message.setMessage(MESSAGE_BREAK_BATCH, "", "", 0);
		argMsg.set(message);
		iRad++;
		if(iRad > 99999)
			iRad = 1;
		argMsg.setTime(szCurrentTime, iRad);
		chain->signal(pMsg);
	}
}

void dealSignal(int sig)
{
	if(sig == SIGTERM)
	{
		theLog<<"收到终止程序的信号："<<sig<<endi;
		bGetExitSig = true;
	}
	else
		bGetExitSig = false;
}

bool checkAnotherDay(char *startTime)
{
	char szNow[DATETIME_LEN+1];
	getCurTime(szNow);
	if( strncmp(szNow, startTime, 8) != 0 )
	{
		strcpy(startTime, szNow);
		return true;
	}
	else
		return false;
}

